## Отчет по лабораторной работе №3

### 1) Оптимизация конфигурации PostgreSQL 

#### shared_buffers 
Назначение: Кэширование часто используемых данных для сокращения обращений к диску.\
Значение: 1 ГБ (25% от общего объёма памяти).\
Обоснование:

Превышение 25% ОЗУ вызывает конкуренцию с кэшем ОС

Оптимально для хранения рабочих наборов данных небольших БД

#### work_mem
Назначение: Память для операций сортировки, хэширования и соединений.\
Значение: 10–16 МБ (рекомендация для 100 подключений).\
Обоснование:

Значения >20 МБ при 100 подключениях могут исчерпать память

Признак недостатка: Sort Method: external merge Disk в плане запроса

#### maintenance_work_mem
Назначение: Память для операций обслуживания (VACUUM, индексация).\
Значение: 256 МБ (6% от ОЗУ).\
Обоснование:

Безопасный объём для ограниченной памяти

Ускоряет восстановление дампов в 2-4 раза

#### effective_cache_size
Назначение: Оценка общего кэша (ОС + PostgreSQL).\
Значение: 3 ГБ (75% от ОЗУ).\
Обоснование:

Помогает планировщику выбирать индексные сканы

Не влияет на реальное потребление памяти


Выводим текущие показатели параметров:

![work_mem и переменные до изменений 1](https://github.com/user-attachments/assets/aa460e85-8d72-4618-9f1c-42119fc92459)

Меняем их и перезагружаем систему командой sudo systemctl restart postgresql@15-main

Новые показания параметров:

![переменные после 1 1](https://github.com/user-attachments/assets/0fdd4c05-2179-48ad-a6e8-876270dd0e4f)



### 2) Создание и анализ индексов

Вставляем в существующую таблицу mytable большое количество данных\
с попомщью команды:\

INSERT INTO mytable (name, value)\
SELECT 'Name ' || i, i\
FROM generate_series(1, 100000) AS i;\

Данные в mytable:
![2](https://github.com/user-attachments/assets/87b5e3a0-111a-46c2-81e0-cacf5b435181)

Выполняем запросы до создания индекса:

EXPLAIN SELECT * FROM mytable WHERE value > 50000;

![2 3 explain](https://github.com/user-attachments/assets/14a286b1-1224-4666-b0d5-b71a7c8e98b0)

EXPLAIN ANALYZE SELECT * FROM mytable WHERE value > 50000;

![2 4 analyzing explain](https://github.com/user-attachments/assets/5f9ed4b8-919f-4a2d-83fb-57780c5b825b)

Сздаем индекс:
![2 5 создали индекс](https://github.com/user-attachments/assets/ebf4933f-b227-4267-be7a-3ea828c1e2c7)

Выполняем запросы:

EXPLAIN SELECT * FROM mytable WHERE value > 50000;

![2 6 explain](https://github.com/user-attachments/assets/1a6ba6ef-7cdb-4f25-bacb-bdb907c80ecd)

EXPLAIN ANALYZE SELECT * FROM mytable WHERE value > 50000;

![2 7 explain analyzing](https://github.com/user-attachments/assets/f6f5cd57-6240-4833-88a3-dbda19c381ac)


Сравнение планов и времени выполнения

До создания индекса:\
План: Seq Scan\
Время выполнения: Более длительное из-за последовательного сканирования всей таблицы.

После создания индекса:\
План: Index Scan\
Время выполнения: Короче, так как индекс позволяет быстро находить необходимые строки.

Вывод\
Использование индексов существенно улучшает производительность запросов, особенно при работе с большими таблицами. EXPLAIN и EXPLAIN ANALYZE помогают анализировать планы выполнения и оптимизировать запросы.

### 3) Хранимые функции 




### 4) Триггеры


### 5) Автоматическая очистка и статистика (VACUUM, ANALYZE) 



